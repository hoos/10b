<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>EMMA User Guide</title><link href="../skin/css/doc.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.66.1" name="generator"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="start"></a>EMMA User Guide</h2></div><div><h3 class="subtitle"><i>A Step-by-Step Introduction to EMMA coverage toolkit</i></h3></div><div><p class="copyright">Copyright &copy; 2001-2004 Vlad Roubtsov</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#N10012">1. Overview</a></span></dt><dt><span class="sect1"><a href="#introCMDLINE">2. Getting Started (<span class="emphasis"><em>command line</em></span>)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N10052">2.1. Adding EMMA command line tools to your classpath</a></span></dt><dt><span class="sect2"><a href="#N1006B">2.2. <span><b class="command">emmarun</b></span>: instrumenting Java classes
on-the-fly</a></span></dt><dt><span class="sect2"><a href="#offlineCMDLINE">2.3. Offline mode: separating instrumentation and execution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#introANT">3. Getting Started (<span class="emphasis"><em>ANT</em></span>)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#setupANT">3.1. Adding EMMA tasks to your ANT build</a></span></dt><dt><span class="sect2"><a href="#N101C4">3.2. <span><b class="command">&lt;emmajava&gt;</b></span>: instrumenting Java classes
on-the-fly</a></span></dt><dt><span class="sect2"><a href="#N10291">3.3. Offline mode: separating instrumentation and execution</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10012"></a>1.&nbsp;Overview</h2></div></div></div><p>EMMA is a tool for measuring <span class="emphasis"><em>coverage</em></span> of Java
software. Such a tool is essential for detecting dead code and verifying
which parts of your application are actually exercised by your test suite
and interactive use.</p><p>EMMA's design strives for several, very elusive in their
    combination, goals:
      <div class="itemizedlist"><ul type="square"><li style="list-style-type: square"><p>report rich coverage analysis data without introducing
significant overhead during <span class="emphasis"><em>either</em></span> build
<span class="emphasis"><em>or</em></span> execution time</p></li><li style="list-style-type: square"><p>be useful in team development environments, while at the
same time enabling fast individual develop-test cycle</p></li><li style="list-style-type: square"><p>support quick development and testing of small standalone
Java applications as well as scale up to massive enterprise sotfware suites
containing thousands of Java classes</p></li></ul></div>
</p><p>EMMA differs from other coverage tools in its extreme orientation
towards <span class="emphasis"><em>fast</em></span> iterative develop-test style of writing
software. JVM Profiler Interface (JVMPI)-based tools do not require an
instrumented source build, but the runtime overhead of running with JVMPI on
is empirically known to be very high and results in depressingly slow
testsuite runs. For tools based on source code instrumentation, having to
wait for a full source code rebuild just to check coverage metrics is not
something a normal developer wants to do several times during a day. EMMA's
goal is to be so <span class="emphasis"><em>unintrusive</em></span> that frequent daily
checking of coverage numbers becomes second nature to
<span class="emphasis"><em>every</em></span> developer on the team, if not a completely
automatic byproduct of every test run.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introCMDLINE"></a>2.&nbsp;Getting Started (<span class="emphasis"><em>command line</em></span>)</h2></div></div></div><p>This section introduces EMMA command line tools. It starts with an
example of how to run an application so that coverage instrumentation is
performed on-the-fly, as the classes are loaded by the JVM, and then repeats
the same process by breaking it into distinct
instrumentation/execution/reporting steps.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Sample source code</h3><p>The source code located in <tt class="filename">examples/src</tt>
directory of EMMA distribution is used for all examples in this
tutorial.</p></div><p><a href="#introANT" title="3.&nbsp;Getting Started (ANT)">Section&nbsp;3, &ldquo;Getting Started (<span class="emphasis"><em>ANT</em></span>)&rdquo;</a> works with the same sample application
through Apache ANT build tool. All of EMMA's command-line functionality is
available via EMMA's ANT tasks and there is some duplication of content
between this and the following sections, so you might want to skip ahead if
you expect to obtain coverage through ANT builds exclusively. You should
also skip ahead if you've already gone through "Getting Started" steps on
EMMA's web site.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10052"></a>2.1.&nbsp;Adding EMMA command line tools to your classpath</h3></div></div></div><p>The recommended way to install EMMA command.line tools is to
make emma.jar an extension library for your Java Runtime Environment (JRE).
This is accomplished simply by copying emma.jar to
<tt class="filename">&lt;your&nbsp;jre&nbsp;dir&gt;/lib/ext/</tt> directory for
whichever JRE you use from command line.</p><p>EMMA distribution neither depends on any external Java libraries
nor includes them inside EMMA jars. This means installing EMMA as a JRE
extension will not pollute your classpath with unknown versions of Java
libraries that you might be using elsewhere in your work. This also has the
advantage of setting up <tt class="filename">emma.jar</tt> as a trusted Java
library, which is useful for collecting coverage in security sensitive
configurations.	</p><p>Still, if you are wary of adding a third-party library as a
standard JRE extension, just make sure that all your EMMA command line
invocations add <tt class="filename">emma.jar</tt> to the JVM classpath:</p><pre class="screen">
&gt;java -cp .../lib/emma.jar &lt;emma or emmarun command&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1006B"></a>2.2.&nbsp;<span><b class="command">emmarun</b></span>: instrumenting Java classes
on-the-fly</h3></div></div></div><p>Assuming you are in the <tt class="filename">examples</tt> directory
of EMMA distribution, start by compiling the example source code:</p><pre class="screen">
&gt;mkdir out 
&gt;javac -d out -g src/*.java src/search/*.java</pre><p>You can now run the main demo driver:</p><pre class="screen">
&gt;java -cp out Main
main(): running doSearch()...
main(): done</pre><p>To run the same program with coverage data collection, just insert
<span><b class="command">emmarun</b></span> in front of your program's main class
name:</p><pre class="screen">
&gt;java emmarun -cp out Main
main(): running doSearch()...
main(): done
EMMA: writing [txt] report to [...coverage.txt] ...</pre><p>The default text coverage report is generated in the current
directory:</p><pre class="screen">
[EMMA v2.0.3611 report, generated Sun Jan 11 14:18:08 CST 2004]
-------------------------------------------------------------------------------
OVERALL COVERAGE SUMMARY:
[class, %]      [method, %]     [block, %]      [line, %]       [name]
100% (3/3)      100% (7/7)      95%  (116/122)  100% (29/29)    all classes

OVERALL STATS SUMMARY:

total packages: 2
total classes:  3
total methods:  7
total executable files: 3
total executable lines: 29

COVERAGE BREAKDOWN BY PACKAGE:

[class, %]      [method, %]     [block, %]      [line, %]       [name]
100% (2/2)      100% (4/4)      91%  (64/70)    100% (18/18)    search
100% (1/1)      100% (3/3)      100% (52/52)    100% (11/11)    default package
-------------------------------------------------------------------------------</pre><p>Code coverage has never been easier! This on-the-fly
instrumentation mode is handy for light-weight testing of
<tt class="function">main()</tt> test methods, individual classes, and small- to-
mid-size programs. <span><b class="command">emmarun</b></span> also works well with Swing
applications.

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Other report types</h3><p>By default, <span><b class="command">emmarun</b></span> generates a
plain-text report only. The default report's depth is <tt class="option">all</tt>
which means to show the overall coverage summary followed by breakdown by
package. You can increase the default depth to include package and source
file summaries. This and many other aspects of EMMA report generation can be
configured using command line
(<tt class="option">-D&lt;report&nbsp;property&gt;=&lt;value&gt;</tt>) or an EMMA
configuration file. See <a class="olink" href="../reference_single/reference.html#prop-ref">Chapter3, EMMA Property Reference</a>
in the reference manual for full details on EMMA configuration. Also, all EMMA command line tools
provide usage information in response to <tt class="option">-h</tt> option.</p></div>
      </p><p><span><b class="command">emmarun</b></span> application runner uses an
instrumenting classloader to add bytecode instrumentation to Java classes as
they are being loaded by the JVM. For efficiency reasons,
<span><b class="command">emmarun</b></span> does not scan your entire classpath before it
starts running. This has the side effect of only reporting on the classes
that got loaded by the application. If your intent is to base coverage
metrics on the full set of classes in the classpath, you can use the
<tt class="option">-f</tt> option.</p><p>Although it was not the case with this tutorial's sample code,
chances are your application has third-party library dependencies and you
are not interested in their coverage metrics. There are two ways to handle
this:

<div class="itemizedlist"><ul type="disc" compact="compact"><li><p>List third-party libraries in the JVM's classpath, not
<span><b class="command">emmarun</b></span>'s <tt class="option">-cp</tt> option:</p><pre class="screen">
&gt;java -cp ...somelib.jar emmarun -cp out Main</pre></li><li><p>Use a coverage filter to make sure that only the classes
of interest are instrumented:</p><pre class="screen">
&gt;java emmarun -cp out;...somelib.jar -ix +Main,+search.*  Main</pre></li></ul></div> If these techniques are not sufficient (e.g., you need to
exclude testcases from coverage and they are in the same Java packages as
the application code and do not follow a sensible naming pattern), you can
always switch to offline instrumentation as described next.</p><p><b>Further reading.&nbsp;</b>This has been a quick intro to EMMA's on-the-fly command line
instrumentation mode. For further details see <a class="olink" href="../reference_single/reference.html#tool-ref.run">Section2, &lt;emmajava&gt;/emmarun</a> in the reference manual.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="offlineCMDLINE"></a>2.3.&nbsp;Offline mode: separating instrumentation and execution</h3></div></div></div><p>As convenient as the on-the-fly mode is, in many cases it is not
sufficient. For example, running a commercial J2EE container in a custom
instrumenting classloader is practically impossible. Certain (bad) coding
practices also fail for code executing in a custom classloader. Finally, in
large scale development there is a common need to collect and merge coverage
data from multiple execution runs and multiple JVM processes.</p><p>This is where separate instrument/execute/report phases are a
necessity. This section repeats the previous exercise using
<span><b class="command">emma</b></span> command line tool, which provides several
subcommands for managing EMMA's offline code coverage analysis:
<span><b class="command">instr</b></span>, <span><b class="command">merge</b></span>, and
<span><b class="command">report</b></span> (there is also a <span><b class="command">run</b></span> equivalent
of <span><b class="command">emmarun</b></span> for scripting convenience).</p><p>If you skipped the previous exercise, you need to compile the
sample source code at this time:</p><pre class="screen">
&gt;cd ...samples
&gt;mkdir out 
&gt;javac -d out -g src/*.java src/search/*.java</pre><p>Now, you are going to instrument classes produced by
<span><b class="command">javac</b></span> (it's kind of a second compilation phase). EMMA can
do "in place" instrumentation (<span class="emphasis"><em>overwrite</em></span> mode), whereby
the classes and jar files are overwritten with their instrumented versions.
However, this is easy to abuse, so for now we are going to be careful and
create a separate directory for coverage-instrumented output:</p><pre class="screen">
&gt;mkdir outinstr
&gt;java emma instr -d outinstr -ip out

EMMA: processing instrumentation path ...
EMMA: instrumentation path processed in 116 ms
EMMA: [3 class(es) instrumented, 0 resource(s) copied]
EMMA: metadata merged into [...coverage.em] {in 31 ms}</pre><p>Several instrumented classes have been added to
<tt class="filename">outinstr</tt> directory and class
<span class="emphasis"><em>metadata</em></span> has been dumped into a
<tt class="filename">coverage.em</tt> file. Note that <span><b class="command">instr</b></span>
accepts a regular classpath string (containing archives and class
directories) as input: this is very convenient for makefile integration
because existing makefiles tend to already have macros for various
classpaths in a project.

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Instrumenting just the right classes</h3><p>Unlike some other tools, EMMA's design is based around
filtering for the right set of classes at instrumentation time. Doing so
allows EMMA to scale to enterprise size projects and ensures the best
performance throughout all three offline stages: instrumentation, execution,
and reporting. To select a subset of classes to be processed, you could give
<span><b class="command">instr</b></span> several <span><b class="command">-ix</b></span> options, each
containing a comma-separated list of inclusion/exlusion patterns. See <a class="olink" href="../reference_single/reference.html#instrset.filters">Section6.2, Coverage filters</a> in the
reference manual for full details.</p></div>
      </p><p>Now the instrumented application can be run. In a real-world
project you might be packaging the instrumented classes in an archive to be
deployed in an application server, but in this tutorial we just load the
classes from disk:</p><pre class="screen">
&gt;java -cp <a name="D0-co" href="#D0"><img border="0" alt="1" src="../images/callouts/1.png"></a>outinstr;out Main

EMMA: collecting runtime coverage data ...
main(): running doSearch()...
main(): done
EMMA: runtime coverage data merged into [...coverage.ec] {in 32 ms}</pre><p>When the JVM exits, EMMA runtime dumps the <span class="emphasis"><em>runtime
coverage profile</em></span> into a <tt class="filename">coverage.ec</tt> file
(the precise names and locations of all files created by EMMA are
configurable, the above is just EMMA's default behavior).

<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Don't forget the classpath</h3><div class="calloutlist"><table summary="Callout list" border="0"><tr><td align="left" valign="top" width="5%"><a name="D0"></a><a href="#D0-co"><img border="0" alt="1" src="../images/callouts/1.png"></a> </td><td align="left" valign="top"><p>Notice an important detail: the instrumented classes
must appear first in the classpath. Also, <span><b class="command">instr</b></span> does not
copy non-executable items like interfaces and resource bundles, so you need
to have the original <tt class="filename">out</tt> behind
<tt class="filename">outinstr</tt> for everything to work.</p></td></tr></table></div></div></p><p>And finally, we combine the class metadata and runtime coverage
profile to produce a plain text and an HTML reports:</p><pre class="screen">
&gt;java emma report -r txt,html -in coverage.em -in coverage.ec

EMMA: 2 file(s) read and merged in 43 ms
EMMA: writing [txt] report to [...coverage.txt] ...
EMMA: writing [html] report to [...coverage/index.html] ...</pre><p>Note that there could be several instrumentation and execution
stages and <span><b class="command">report</b></span> will happily merge all of the results
in memory before generating the reports. To merge all files on disk (for
maintenance and disk storage reasons) you can use
<span><b class="command">merge</b></span>:</p><pre class="screen">
&gt;java emma merge -in coverage.em -in coverage.ec -out coverage.es

EMMA: processing input files ...
EMMA: 2 file(s) read and merged in 42 ms
EMMA: merged/compacted data written to [...coverage.es] {in 58 ms}</pre><p>In EMMA's offline mode, you are in complete control of mixing and
matching metadata and coverage data from different application runs. You can
instruct all tools to merge all types of data in the same file or keep everything in
separate file repositories. EMMA tools default to
<tt class="option">merge=true</tt> output file mode for metadata and runtime
coverage data, but properties exist to alter this behavior. See <a class="olink" href="../reference_single/reference.html#prop-ref">Chapter3, EMMA Property Reference</a> in the reference manual for further details.</p><p><b>Further reading.&nbsp;</b>This has been a quick intro to EMMA's offline
instrumentation tools for command line. For further details read the reference manual
starting with <a class="olink" href="../reference_single/reference.html#tool-ref.instr">Section3, &lt;instr&gt;/instr</a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introANT"></a>3.&nbsp;Getting Started (<span class="emphasis"><em>ANT</em></span>)</h2></div></div></div><p>This section introduces EMMA ANT tasks. It starts with an example
of how to run an application from ANT so that coverage instrumentation is
performed on-the-fly, as the classes are loaded by the JVM, and then repeats
the same process by breaking it into distinct
instrumentation/execution/reporting steps. The ANT logic sequence will be
equivalent to what was described previously, in <a href="#introCMDLINE" title="2.&nbsp;Getting Started (command line)">Section&nbsp;2, &ldquo;Getting Started (<span class="emphasis"><em>command line</em></span>)&rdquo;</a>. Additionally, the ANT <tt class="filename">build.xml</tt> files
created below will have logic for enabling and disabling coverage through
ANT command line.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Sample source code and ANT build files</h3><p>The source code located in <tt class="filename">examples/src</tt>
directory of EMMA distribution is used for all examples in this tutorial.
EMMA distribution also includes two sample ANT buildfiles,
<tt class="filename">build-onthefly.xml</tt> and
<tt class="filename">build-offline.xml</tt>, that correspond to the two
approaches to collecting coverage. Although it would have been possible to
keep everything in a single file, using distinct files allows for more
clarity.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="setupANT"></a>3.1.&nbsp;Adding EMMA tasks to your ANT build</h3></div></div></div><p>EMMA ANT tasks can be deployed in any of the many ways available
for custom ANT taskdefs. This tutorial assumes that you have an EMMA
distribution directory that contains both <tt class="filename">emma.jar</tt> and
<tt class="filename">emma_ant.jar</tt>. The latter archive is what contains EMMA
taskdefs, however, both archives need to be visible to ANT. The easiest way
to accomplish this is with the following definitions in your
<tt class="filename">build.xml</tt>:</p><pre class="programlisting">
  &lt;!-- directory that contains emma.jar and emma_ant.jar: --&gt;
  &lt;property name="emma.dir" value="${basedir}/../lib" /&gt;

  &lt;path id="emma.lib" &gt;<a name="A0-co" href="#A0"><img border="0" alt="1" src="../images/callouts/1.png"></a>
    &lt;pathelement location="${emma.dir}/emma.jar" /&gt;
    &lt;pathelement location="${emma.dir}/emma_ant.jar" /&gt;
  &lt;/path&gt;

  &lt;taskdef resource="emma_ant.properties" classpathref="emma.lib" /&gt;</pre><p>
      <div class="calloutlist"><table summary="Callout list" border="0"><tr><td align="left" valign="top" width="5%"><a name="A0"></a><a href="#A0-co"><img border="0" alt="1" src="../images/callouts/1.png"></a> </td><td align="left" valign="top"><p>Even though this path definition can be merged into the
<span><b class="command">&lt;taskdef&gt;</b></span>, a path element with this id will come in
handy later in the build.</p></td></tr></table></div></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N101C4"></a>3.2.&nbsp;<span><b class="command">&lt;emmajava&gt;</b></span>: instrumenting Java classes
on-the-fly</h3></div></div></div><p>Let's create a simple ANT build file for the source code in
<tt class="filename">examples/src</tt>. Add this after EMMA task
definitions:</p><pre class="programlisting">
  &lt;!-- root directory for the example source code: --&gt; 
  &lt;property name="src.dir" value="${basedir}/src" /&gt;

  &lt;!-- javac class output directory: --&gt;
  &lt;property name="out.dir" value="${basedir}/out" /&gt;

  &lt;target name="init" &gt;
    &lt;mkdir dir="${out.dir}" /&gt;
    &lt;path id="run.classpath" &gt;
      &lt;pathelement location="${out.dir}" /&gt;
    &lt;/path&gt;
  &lt;/target&gt;

  &lt;target name="compile" depends="init" description="compiles the example source code" &gt;
    &lt;javac debug="on" srcdir="${src.dir}" destdir="${out.dir}" /&gt;
  &lt;/target&gt;

  &lt;target name="run" depends="init, compile" description="runs the examples" &gt;
    &lt;java classname="Main"
          classpathref="run.classpath"
    &gt;
    &lt;/java&gt;
  &lt;/target&gt;</pre><p>You can now compile and run the example:</p><pre class="screen">
&gt;ant run
Buildfile: build.xml

init:
    [mkdir] Created dir: .../examples/out

compile:
    [javac] Compiling 4 source files to .../examples/out

run:
     [java] main(): running doSearch()...
     [java] main(): done

BUILD SUCCESSFUL
Total time: 5 seconds</pre><p><span><b class="command">&lt;emmajava&gt;</b></span> is an EMMA extension of ANT
stock <span><b class="command">&lt;java&gt;</b></span> task that is an ANT adapter to the
same instrumenting application runner as used by EMMA
<span><b class="command">emmarun</b></span> command line tool. Upgrading your build to do
code coverage on-the-fly is very easy: just replace &lt;java&gt; tags with
&lt;emmajava&gt; tags for tasks that run your application or test cases.
Don't worry, your build is not now in a permanent coverage-enabled mode:
<span><b class="command">&lt;emmajava&gt;</b></span> becomes a pass-through to the normal
<span><b class="command">&lt;java&gt;</b></span> when its <tt class="option">enabled</tt> attribute
is set to <tt class="option">false</tt>:</p><pre class="programlisting">
  &lt;target name="emma" description="turns on EMMA's on-the-fly instrumentation mode" &gt;
    &lt;property name="emma.enabled" value="true" /&gt;
  &lt;/target&gt;

  &lt;target name="run" depends="init, compile" description="runs the examples" &gt;
    &lt;emmajava enabled="${emma.enabled}" libclasspathref="emma.lib" 
              classname="Main"
              classpathref="run.classpath"
    &gt;
    &lt;/emmajava&gt;
  &lt;/target&gt;</pre><p>Now, whenever you insert <span><b class="command">emma</b></span> before any run
targets on ANT's command line, you enable on-the-fly coverage
instrumentation and reporting (but ANT commands without <span><b class="command">emma</b></span>
continue to function as before):</p><pre class="screen">
&gt;ant emma run
Buildfile: build.xml

emma:

init:
    [mkdir] Created dir: .../examples/out

compile:
    [javac] Compiling 4 source files to .../examples/out

run:
 [emmajava] main(): running doSearch()...
 [emmajava] main(): done
 [emmajava] EMMA: writing [txt] report to [.../coverage.txt] ...

BUILD SUCCESSFUL
Total time: 7 seconds</pre><p>The default text coverage report is generated in the current
directory:</p><pre class="screen">
[EMMA v2.0.3611 report, generated Sun Jan 11 14:18:08 CST 2004]
-------------------------------------------------------------------------------
OVERALL COVERAGE SUMMARY:

[class, %]      [method, %]     [block, %]      [line, %]       [name]
100% (3/3)      100% (7/7)      95%  (116/122)  100% (29/29)    all classes

OVERALL STATS SUMMARY:

total packages: 2
total classes:  3
total methods:  7
total executable files: 3
total executable lines: 29

COVERAGE BREAKDOWN BY PACKAGE:

[class, %]      [method, %]     [block, %]      [line, %]       [name]
100% (2/2)      100% (4/4)      91%  (64/70)    100% (18/18)    search
100% (1/1)      100% (3/3)      100% (52/52)    100% (11/11)    default package
-------------------------------------------------------------------------------</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Other report types</h3><p>By default, <span><b class="command">&lt;emmajava&gt;</b></span> generates a
plain-text report only. The default report's depth is <tt class="option">all</tt>
which means to show the overall coverage summary followed by breakdown by
package. You can increase the default depth to include package and source
file summaries. This and many other aspects of EMMA report generation can be
configured using various attributes and nested elements that
<span><b class="command">&lt;emmajava&gt;</b></span> adds to <span><b class="command">&lt;java&gt;</b></span>.
These extensions only take effect when the task is in enabled state and have
no impact on the build otherwise. See <a class="olink" href="../reference_single/reference.html#prop-ref">Chapter3, EMMA Property Reference</a>
in the reference manual for full details on EMMA configuration.</p></div><p><span><b class="command">&lt;emmajava&gt;</b></span> application runner uses an
instrumenting classloader to add bytecode instrumentation to Java classes as
they are being loaded by the JVM. For efficiency reasons,
<span><b class="command">&lt;emmajava&gt;</b></span> does not scan your entire classpath
before it starts running. This has the side effect of only reporting on the
classes that got loaded by the application. If your intent is to base
coverage metrics on the full set of classes in the classpath, you can set
<tt class="option">fullmetadata</tt> task attribute to <tt class="option">true</tt>. Here
is an example that also adds some extra reports and makes sure the HTML
report generator has access to the source code by setting
<tt class="option">sourcepath="${src.dir}"</tt>:</p><pre class="programlisting">
  &lt;!-- output directory used for EMMA coverage reports: --&gt;
  &lt;property name="coverage.dir" value="${basedir}/coverage" /&gt;

  &lt;target name="run" depends="init, compile" description="runs the examples" &gt;
    &lt;emmajava enabled="${emma.enabled}" libclasspathref="emma.lib" 
              fullmetadata="yes" sourcepath="${src.dir}"
              classname="Main"
              classpathref="run.classpath"
    &gt;
      &lt;txt outfile="${coverage.dir}/coverage.txt" /&gt;
      &lt;xml outfile="${coverage.dir}/coverage.xml" /&gt;
      &lt;html outfile="${coverage.dir}/coverage.html"  /&gt;
    &lt;/emmajava&gt;
  &lt;/target&gt;
</pre><p>Although this was not the case with this tutorial's sample code,
chances are your application has third-party library dependencies and you
are not interested in their coverage metrics. There are two ways to handle
this with <span><b class="command">&lt;emmajava&gt;</b></span>:</p><div class="calloutlist"><table summary="Callout list" border="0"><tr><td align="left" valign="top" width="5%"><a name="C0"></a><a href="#C0-co"><img border="0" alt="1" src="../images/callouts/1.png"></a> </td><td align="left" valign="top"><p>List libraries in the JVM's
classpath, not <span><b class="command">&lt;emmajava&gt;</b></span>'s classpath. You do that
by adding them to <span><b class="command">&lt;emmajava&gt;</b></span>'s
<tt class="option">emmaclasspath</tt> attribute instead of the usual
<tt class="option">classpath</tt>:

<pre class="programlisting">
    &lt;emmajava enabled="${emma.enabled}" libclasspathref="allmylibs.path"<a name="C0-co" href="#C0"><img border="0" alt="1" src="../images/callouts/1.png"></a> 
              classname="Main"
              classpathref="run.classpath"
    &gt;
    &lt;/emmajava&gt;</pre>
     </p></td></tr><tr><td align="left" valign="top" width="5%"><a name="C1"></a><a href="#C1-co"><img border="0" alt="1" src="../images/callouts/1.png"></a> </td><td align="left" valign="top"><p>Use a coverage filter to
make sure that only the classes of interest are instrumented:

<pre class="programlisting">
    &lt;emmajava enabled="${emma.enabled}" libclasspathref="emma.lib" 
              classname="Main"
              classpathref="run.classpath"
    &gt;
      <a name="C1-co" href="#C1"><img border="0" alt="1" src="../images/callouts/1.png"></a>&lt;filter includes="Main, search.*" /&gt;
    &lt;/emmajava&gt;</pre>

      </p></td></tr></table></div><p>If these techniques are not sufficient (e.g., you need to
exclude testcases from coverage and they are in the same Java packages as
the application code and do not follow a sensible naming pattern), you can
always switch to offline instrumentation as described next. Offline
instrumentation does not keep everything in memory and ultimately gives you
much more control over what gets instrumented.</p><p>To summarize, an existing <tt class="filename">build.xml</tt> can be
converted to use EMMA's on-the-fly instrumentation mode by following these
steps:
	<div class="orderedlist"><ol type="1" compact="compact"><li><p>add EMMA task definitions</p></li><li><p>replace the necessary invocations of
<span><b class="command">&lt;java&gt;</b></span> with
<span><b class="command">&lt;emmajava&gt;</b></span></p></li><li><p>configure coverage paths and inclusion/exclusion
filters</p></li><li><p>configure coverage reports</p></li><li><p>make sure there is a way to turn coverage instrumentation
off</p></li></ol></div>
</p><p><b>Futher reading.&nbsp;</b>This has been a quick intro to EMMA's on-the-fly ANT
instrumentation mode. For further details see <a class="olink" href="../reference_single/reference.html#tool-ref.run">Section2, &lt;emmajava&gt;/emmarun</a> in the reference manual.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10291"></a>3.3.&nbsp;Offline mode: separating instrumentation and execution</h3></div></div></div><p>As convenient as the on-the-fly mode is, in many cases it is not
sufficient. For example, running a commercial J2EE container in a custom
instrumenting classloader is practically impossible. Certain (bad) coding
practices also fail for code executing in a custom classloader. Finally, in
large scale development there is a common need to collect and merge coverage
data from multiple execution runs and multiple JVM processes.</p><p>This is where separate instrument/execute/report phases are a
necessity. This section repeats the previous exercise using
<span><b class="command">&lt;emma&gt;</b></span> ANT task, which provides several subtasks
for managing offline instrumentation: <span><b class="command">&lt;instr&gt;</b></span>,
<span><b class="command">&lt;merge&gt;</b></span>, and <span><b class="command">&lt;report&gt;</b></span>. In
a typical ANT build each <span><b class="command">&lt;emma&gt;</b></span> tag acts as a
container for an arbitrary sequence of sub-tags. This design allows for a
simple form of build flow control, whereby entire sequences of EMMA commands
can be disabled at a single point.</p><p>Let's go back to the starting point of the previous section and
assume that you have a <tt class="filename">build.xml</tt> file with EMMA tasks
imported and the following build infrastructure created:</p><pre class="programlisting">
  &lt;!-- root directory for the example source code: --&gt; 
  &lt;property name="src.dir" value="${basedir}/src" /&gt;

  &lt;!-- javac class output directory: --&gt;
  &lt;property name="out.dir" value="${basedir}/out" /&gt;

  &lt;target name="init" &gt;
    &lt;mkdir dir="${out.dir}" /&gt;
    &lt;path id="run.classpath" &gt;
      &lt;pathelement location="${out.dir}" /&gt;
    &lt;/path&gt;
  &lt;/target&gt;

  &lt;target name="compile" depends="init" description="compiles the example source code" &gt;
    &lt;javac debug="on" srcdir="${src.dir}" destdir="${out.dir}" /&gt;
  &lt;/target&gt;

  &lt;target name="run" depends="init, compile" description="runs the examples" &gt;
    &lt;java classname="Main" classpathref="run.classpath" &gt;
 &lt;/target&gt;</pre><p>In a real world project the actual application could be either
an end user application or your test framework driver. Adding offline
coverage instrumentation and reporting to this build is not much harder than
it was in the command line tools case, in <a href="#offlineCMDLINE" title="2.3.&nbsp;Offline mode: separating instrumentation and execution">Section&nbsp;2.3, &ldquo;Offline mode: separating instrumentation and execution&rdquo;</a>.
All you need to do is sandwich <span><b class="command">&lt;java&gt;</b></span> (or your test
framework driver, or anything that can run on Java classes) between EMMA's
<span><b class="command">&lt;instr&gt;</b></span> and
<span><b class="command">&lt;report&gt;</b></span>:</p><pre class="programlisting">
  &lt;target name="emma" description="turns on EMMA instrumentation/reporting" &gt;
    &lt;property name="emma.enabled" value="true" /&gt;
    <a name="B0-co" href="#B0"><img border="0" alt="1" src="../images/callouts/1.png"></a>&lt;!-- EMMA instr class output directory: --&gt;
    &lt;property name="out.instr.dir" value="${basedir}/outinstr" /&gt;
    &lt;mkdir dir="${out.instr.dir}" /&gt;
  &lt;/target&gt;

  &lt;target name="run" depends="init, compile" description="runs the examples" &gt;
    &lt;emma enabled="${emma.enabled}" &gt;
      &lt;instr instrpathref="run.classpath"<a name="B0.5-co" href="#B0.5"><img border="0" alt="2" src="../images/callouts/2.png"></a>
             destdir="${out.instr.dir}"	
             metadatafile="${coverage.dir}/metadata.emma"
             merge="true"
      /&gt;
    &lt;/emma&gt;

    <a name="B1-co" href="#B1"><img border="0" alt="3" src="../images/callouts/3.png"></a>
    &lt;java classname="Main" fork="true"<a name="B2-co" href="#B2"><img border="0" alt="4" src="../images/callouts/4.png"></a> &gt;
      &lt;classpath&gt;
       <a name="B3-co" href="#B3"><img border="0" alt="5" src="../images/callouts/5.png"></a>&lt;pathelement location="${out.instr.dir}" /&gt;
        &lt;path refid="run.classpath" /&gt;
        &lt;path refid="emma.lib" /&gt;
      &lt;/classpath&gt; 
      &lt;jvmarg value="-Demma.coverage.out.file=${coverage.dir}/coverage.emma" /&gt;<a name="B4-co" href="#B4"><img border="0" alt="6" src="../images/callouts/6.png"></a>
      &lt;jvmarg value="-Demma.coverage.out.merge=false" /&gt;
    &lt;/java&gt;

    &lt;emma enabled="${emma.enabled}" &gt;
      <a name="B5-co" href="#B5"><img border="0" alt="7" src="../images/callouts/7.png"></a>&lt;report sourcepath="${src.dir}" &gt;
        &lt;fileset dir="${coverage.dir}" &gt;
          &lt;include name="*.emma" /&gt;<a name="B6-co" href="#B6"><img border="0" alt="8" src="../images/callouts/8.png"></a>
        &lt;/fileset&gt;

        &lt;txt outfile="${coverage.dir}/coverage.txt" /&gt;
        &lt;html outfile="${coverage.dir}/coverage.html" /&gt;
      &lt;/report&gt;
    &lt;/emma&gt;
  &lt;/target&gt;</pre><p>When EMMA instrumentation is enabled via
<tt class="option">emma.enabled</tt> build property, the sequence of logic here is
as follows:

      <div class="calloutlist"><table summary="Callout list" border="0"><tr><td align="left" valign="top" width="5%"><a name="B0"></a><a href="#B0-co"><img border="0" alt="1" src="../images/callouts/1.png"></a> </td><td align="left" valign="top"><p>Again, there is a
<span><b class="command">emma</b></span> helper target to set <tt class="option">emma.enabled</tt>
to <tt class="option">true</tt>. Additionally, this target defines
<tt class="option">${out.instr.dir}</tt> property for coverage-instrumented output. It is
important that this property exist only when
<tt class="option">emma.enabled=true</tt>, as you will see later.</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="B0.5"></a><a href="#B0.5-co"><img border="0" alt="2" src="../images/callouts/2.png"></a> </td><td align="left" valign="top"><p>EMMA's offline
instrumentor executes and copies instrumented classes into
<tt class="option">${out.instr.dir}</tt>. Class <span class="emphasis"><em>metadata</em></span> is
dumped into a <tt class="filename">metadata.emma</tt> file. (Note that
<span><b class="command">&lt;instr&gt;</b></span> accepts the same
<tt class="option">run.classpath</tt> path element reference as the original build:
this is what makes EMMA so easy to integrate with ANT.)</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="B1"></a><a href="#B1-co"><img border="0" alt="3" src="../images/callouts/3.png"></a> </td><td align="left" valign="top"><p>The application runs with
instrumented classes.</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="B2"></a><a href="#B2-co"><img border="0" alt="4" src="../images/callouts/4.png"></a> </td><td align="left" valign="top"><p>In version 2.0, EMMA's
runtime coverage data is dumped by a JVM exit handler and for this to happen
<span><b class="command">&lt;java&gt;</b></span> needs to be forked.</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="B3"></a><a href="#B3-co"><img border="0" alt="5" src="../images/callouts/5.png"></a> </td><td align="left" valign="top"><p>As in the command line
case, the instrumented classes need to be first in the classpath. Note that
this only happens when <tt class="option">${out.instr.dir}</tt> property has been
defined by <span><b class="command">emma</b></span> helper target. Also,
<span><b class="command">&lt;java&gt;</b></span> needs to have <tt class="filename">emma.jar</tt>
in its classpath (recollect the path reference created in <a href="#setupANT" title="3.1.&nbsp;Adding EMMA tasks to your ANT build">Section&nbsp;3.1, &ldquo;Adding EMMA tasks to your ANT build&rdquo;</a>).</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="B4"></a><a href="#B4-co"><img border="0" alt="6" src="../images/callouts/6.png"></a> </td><td align="left" valign="top"><p>For certainty,
<span><b class="command">&lt;java&gt;</b></span> is configured with an explicit filename that
accepts <span class="emphasis"><em>runtime coverage profile</em></span> data.</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="B5"></a><a href="#B5-co"><img border="0" alt="7" src="../images/callouts/7.png"></a> </td><td align="left" valign="top"><p>EMMA report processor
executes.</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="B6"></a><a href="#B6-co"><img border="0" alt="8" src="../images/callouts/8.png"></a> </td><td align="left" valign="top"><p>The report processor
combines the class metadata and runtime coverage profile to produce a couple
of reports.</p></td></tr></table></div>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Overwrite mode</h3><p>EMMA can do "in place" instrumentation
(<span class="emphasis"><em>overwrite</em></span> mode), whereby the classes and jar files are
overwritten with their instrumented versions. However, this is easy to
abuse, so the build above is being careful and creates a separate directory
for coverage-instrumented output.</p></div>

</p><p>Let's see the new build in action. Again, code coverage is
turned on only if <span><b class="command">emma</b></span> target appears on ANT command line
before any run targets:</p><pre class="screen">
&gt;ant emma run
Buildfile: build.xml

emma:

init:
    [mkdir] Created dir: .../examples/out

compile:
    [javac] Compiling 4 source files to .../examples/out

run:
[emma.instr] processing instrumentation path ...
[emma.instr] instrumentation path processed in 200 ms
[emma.instr] [3 class(es) instrumented, 0 resource(s) copied]
[emma.instr] metadata merged into [.../coverage/metadata.emma] {in 31 ms}
     [java] EMMA: collecting runtime coverage data ...
     [java] main(): running doSearch()...
     [java] main(): done
     [java] EMMA: runtime coverage data written to [.../coverage/coverage.emma] {in 15 ms}
[emma.report] 2 file(s) read and merged in 0 ms
[emma.report] writing [txt] report to [.../coverage/coverage.txt] ...
[emma.report] writing [html] report to [.../coverage/coverage.html] ...

BUILD SUCCESSFUL
Total time: 7 seconds</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Instrumenting just the right classes</h3><p>Unlike some other tools, EMMA's design is based around
filtering for the right set of classes at instrumentation time. Doing so
allows EMMA to scale to enterprise size projects and ensures the best
performance throughout all three offline stages: instrumentation, execution,
and reporting. To select a subset of classes to be processed, you can use
two complementary techniques:
        <div class="orderedlist"><ol type="1" compact="compact"><li><p>segment your ANT path elements well, do not lump
everything into just one <tt class="option">path</tt>. Specifically, keep
third-party libraries, your application classes, and testcase classes in
separate path elements. It will be easy to combine them when needed and code
coverage will be easier because you will have just the right path element to
use as <span><b class="command">&lt;instr&gt;</b></span>'s <tt class="option">instrpath</tt>
attribute or nested element: your application classes.</p></li><li><p>additionally, you can give
<span><b class="command">&lt;instr&gt;</b></span> several <span><b class="command">&lt;filter&gt;</b></span>
nested elements, each potentially containing a list of class name
inclusion/exclusion patterns. This will allow you to zoom in on just the
right part of your application. And adding an ANT command-line override for
one of those will allow every developer on the team to narrow things down to
their own module. See the exact <a class="olink" href="../reference_single/reference.html#tool-ref.instr.filter.ANT">ANT syntax for specifying coverage filters</a> in
the reference manual.</p></li></ol></div></p></div><p>Note that your build can contain several instrumentation and
execution stages and <span><b class="command">&lt;report&gt;</b></span> will happily merge
all of the results in memory before generating the reports. To merge all
files on disk (for maintenance and disk storage reasons) you can use
<span><b class="command">&lt;merge&gt;</b></span> sub-task:

<pre class="programlisting">
  &lt;target name="merge" description="demonstrates dump file merging" &gt;
    &lt;emma&gt;
      &lt;merge outfile="${coverage.dir}/session.emma" &gt;
        &lt;fileset dir="${coverage.dir}" &gt;
          &lt;include name="*.emma" /&gt;
        &lt;/fileset&gt;
      &lt;/merge&gt;
    &lt;/emma&gt;
  &lt;/target&gt;</pre>

In EMMA's offline mode, you are in complete control of
mixing and matching metadata and coverage data from different application
runs. You can instruct all tools to merge all data in the same file or keep
everything in separate file repositories. EMMA tools default to
<tt class="option">merge=true</tt> output file mode for metadata and runtime
coverage data, but properties exist to alter this behavior. See <a class="olink" href="../reference_single/reference.html#prop-ref">Chapter3, EMMA Property Reference</a> in the reference manual for
full details on EMMA configuration.</p><p>To summarize, an existing <tt class="filename">build.xml</tt> can be
converted to use EMMA's offline instrumentation mode by following these steps:
	<div class="orderedlist"><ol type="1" compact="compact"><li><p>add EMMA task definitions</p></li><li><p>add the necessary <span><b class="command">&lt;instr&gt;</b></span> tasks,
making sure that the application classes are instrumented before they are
used at runtime</p></li><li><p>configure classpaths and coverage inclusion/exclusion
filters such that only your application classes, not third-party libraries
or testcases, are instrumented</p></li><li><p>make sure the instrumented classes will be
<span class="emphasis"><em>prepended</em></span> to your application's runtime classpath (that
is, if you are not packaging them as EJBs, a web app, etc
instead)</p></li><li><p>add a <span><b class="command">&lt;report&gt;</b></span> task that
aggregates class metadata and runtime coverage profiles for reporting as
needed</p></li><li><p>make sure there is a way to turn coverage instrumentation
on and off (you can use either the existing ANT solutions for that or the
<tt class="option">enabled</tt> attribute on all EMMA tasks)</p></li></ol></div> 
</p><p><b>Further reading.&nbsp;</b>This has been a quick intro to EMMA's offline instrumentation
	tools for ANT. For further details read the reference manual
	starting with <a class="olink" href="../reference_single/reference.html#tool-ref.instr">Section3, &lt;instr&gt;/instr</a>.</p></div></div></div></body></html>